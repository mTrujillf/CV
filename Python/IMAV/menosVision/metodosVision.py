import numpy as np
import cv2


def blanco_negro_nuevo(image):

    channel3Min = 150.0
    #107.1
    channel3Max = 255.000


    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    bw = cv2.cvtColor(hsv,cv2.COLOR_BGR2GRAY)

    BW = (bw[:, :] >= channel3Min) & (bw[:, :] <= channel3Max)

    BW = BW.astype(float)

    return BW


def blanco_negro_nuevo_inv(image):

    channel3Min = 0.0
    #107.1
    channel3Max = 5.0


    #hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    bw = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)

    BW = (bw[:, :] >= channel3Min) & (bw[:, :] <= channel3Max)

    BW = BW.astype(float)

    return BW

def no_derecho(frame):

    yaw = [-150,-90,-60,60,90,150]

    #frame = blanco_negro_nuevo(frame)

    img1 = frame[0:95,0:168]
    img3 = frame[0:95,338:506]
    #img1 = frame[0:95,169:337]
    #img3 = frame[96:191,507:675]

    img4 = frame[96:191,0:168]
    img5 = frame[96:191,338:506]
    #img4 = frame[192:287,169:337]
    #img5 = frame[192:287,507:675]

    img6 = frame[192:287,0:168]
    img7 = frame[192:287,338:506]

    sumImg6 = sum(sum(img6))
    sumImg4 = sum(sum(img4))
    sumImg1 = sum(sum(img1))
    sumImg3 = sum(sum(img3))
    sumImg5 = sum(sum(img5))
    sumImg7 = sum(sum(img7))

    sumImg = np.array([sumImg6,sumImg4,sumImg1,sumImg3,sumImg5,sumImg7])

    i = sumImg.argmax()

    if i<3:
        tot = sumImg[0] + sumImg[1] + sumImg[2]
    else:
        tot = sumImg[3] + sumImg[4] + sumImg[5]
     
    tot = tot+1
    resp = yaw[i]*(sumImg[i]/tot)

    return resp

def centrar(frame):
    #frame(0,191 , 0,168)
    izq = frame[0:191,0:83]
    der = frame[0:191,84:168]

    sumIzq = sum(sum(izq))
    sumDer = sum(sum(der))

    x = sumDer - sumIzq

    izq1 = izq[0:95,0:83]
    izq2 = izq[96:191,0:83]

    der1 = der[0:95,84:168]
    der2 = der[96:191,84:168]

    sumIzq1 = sum(sum(izq1))
    sumDer1 = sum(sum(der1))
    sumIzq2 = sum(sum(izq2))
    sumDer2 = sum(sum(der2))

    x1 = sumDer1 - sumIzq1
    x2 = sumDer2 - sumIzq2

    if abs(x1) > abs(x2):
        yaw = x1
    else:
        yaw = -x2
    #///////////////////////////////
    #con dos lineas de cinta
    #x = int (x/4000) 
    #yaw = int (yaw/120)
    #////////////////////////////////
    #con una linea de cinta
    x = int (x/2500)

    yaw = int (yaw/150)
    #///////////////////////////////////
    return x,yaw


#function [BW,maskedRGBImage] = createMask(RGB)
#%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
#%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
#%  auto-generated code from the colorThresholder app. The colorspace and
#%  range for each channel of the colorspace were set within the app. The
#%  segmentation mask is returned in BW, and a composite of the mask and
#%  original RGB images is returned in maskedRGBImage.

#% Auto-generated by colorThresholder app on 15-May-2024
#%------------------------------------------------------


#% Convert RGB image to chosen color space
#I = rgb2hsv(RGB);

#% Define thresholds for channel 1 based on histogram settings
#channel1Min = 0.000;
#channel1Max = 1.000;

#% Define thresholds for channel 2 based on histogram settings
#channel2Min = 0.546;
#channel2Max = 1.000;

#% Define thresholds for channel 3 based on histogram settings
#channel3Min = 0.263;
#channel3Max = 0.787;

#% Create mask based on chosen histogram thresholds
#sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
#    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
#    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
#BW = sliderBW;

#% Initialize output masked image based on input image.
#maskedRGBImage = RGB;

#% Set background pixels where BW is false to zero.
#maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

#end


def create_mask(rgb_image):
    """
    Threshold an RGB image using auto-generated code from colorThresholder app.
    Returns the segmentation mask (BW) and a composite of the mask and the original RGB image (maskedRGBImage).
    
    Parameters:
        rgb_image (numpy.ndarray): The input RGB image as a NumPy array.
    
    Returns:
        numpy.ndarray: Binary mask (BW) indicating the thresholded areas.
        numpy.ndarray: The RGB image where non-thresholded areas are set to zero.
    """
    # Convert RGB image to HSV color space
    hsv_image = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2HSV)
    
    # Define thresholds for HSV channels based on histogram settings
    channel1_min = 0.0
    channel1_max = 1.0
    channel2_min = 0.446
    channel2_max = 1.0
    channel3_min = 0.241
    channel3_max = 1.0

    # Create mask based on chosen histogram thresholds
    mask = cv2.inRange(hsv_image, 
                       (channel1_min * 179, channel2_min * 255, channel3_min * 255),
                       (channel1_max * 179, channel2_max * 255, channel3_max * 255))
    
    # Convert mask to boolean
    bw = mask.astype(bool)
    
    # Initialize output masked image based on input image
    masked_rgb_image = rgb_image.copy()
    
    # Set background pixels where BW is false to zero
    masked_rgb_image[~bw] = 0

    return bw, masked_rgb_image
